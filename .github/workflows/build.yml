name: Build strongSwan APK

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  OPENSSL_VERSION: "3.3.1"
  NDK_VERSION: "27.3.13750724"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y autoconf automake libtool pkg-config gettext python3 bison flex gperf perl curl unzip git libssl-dev libgmp-dev

      - name: Set environment
        run: |
          echo "ANDROID_NDK_HOME=/usr/local/lib/android/sdk/ndk/${{ env.NDK_VERSION }}" >> $GITHUB_ENV
          echo "ANDROID_SDK_ROOT=/usr/local/lib/android/sdk" >> $GITHUB_ENV

      - name: Clone strongSwan
        run: git clone --depth 1 https://github.com/strongswan/strongswan.git ss-full

      - name: Generate strongSwan source files
        run: |
          cd ss-full
          ./autogen.sh
          ./configure \
            --enable-openssl \
            --enable-eap-identity \
            --enable-eap-mschapv2 \
            --enable-eap-md5 \
            --enable-eap-gtc \
            --enable-eap-tls \
            --enable-eap-ttls \
            --enable-eap-tnc
          make -j$(nproc) 2>&1 | tail -20 || echo "Host make done"
          if [ ! -f src/libstrongswan/asn1/oid.c ]; then
            cd src/libstrongswan/asn1 && perl oid.pl oid.txt oid.c oid.h && cd ../../..
          fi
          if [ ! -f Android.common.mk ]; then
            VERSION=$(sed -n "s/^PACKAGE_VERSION='\(.*\)'/\1/p" configure | head -1)
            echo "strongswan_VERSION := ${VERSION}" > Android.common.mk
          fi

      - name: Download OpenSSL
        run: |
          curl -fL -o openssl.tar.gz "https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz"
          tar xzf openssl.tar.gz

      - name: Build OpenSSL for Android
        run: |
          set -e
          export ANDROID_NDK_ROOT="${ANDROID_NDK_HOME}"
          export PATH="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin:${PATH}"

          build_ssl() {
            local ABI=$1 TARGET=$2
            echo "===== Building OpenSSL for ${ABI} ====="
            local BUILD_DIR="${GITHUB_WORKSPACE}/openssl-build-${ABI}"
            local OUT_DIR="${GITHUB_WORKSPACE}/openssl-out-${ABI}"
            rm -rf "${BUILD_DIR}" "${OUT_DIR}"
            cp -r "openssl-${{ env.OPENSSL_VERSION }}" "${BUILD_DIR}"
            cd "${BUILD_DIR}"
            ./Configure "${TARGET}" \
              -D__ANDROID_API__=21 \
              --prefix="${OUT_DIR}" \
              --openssldir="${OUT_DIR}" \
              --libdir=lib \
              no-tests no-ui-console
            make -j$(nproc)
            make install_sw
            cd "${GITHUB_WORKSPACE}"
          }

          build_ssl arm64-v8a android-arm64
          build_ssl armeabi-v7a android-arm
          build_ssl x86 android-x86
          build_ssl x86_64 android-x86_64

      - name: Setup OpenSSL in JNI directory
        run: |
          set -e
          OSSL="ss-full/src/frontends/android/app/src/main/jni/openssl"
          mkdir -p "${OSSL}/include"
          cp -r "${GITHUB_WORKSPACE}/openssl-out-arm64-v8a/include/openssl" "${OSSL}/include/"

          for ABI in arm64-v8a armeabi-v7a x86 x86_64; do
            DEST="${OSSL}/${ABI}"
            mkdir -p "${DEST}"
            OUT="${GITHUB_WORKSPACE}/openssl-out-${ABI}/lib"
            for LIB in libcrypto libssl; do
              # Copy the actual .so file (not symlinks)
              REAL=$(find "${OUT}" -name "${LIB}.so*" ! -type l 2>/dev/null | head -1)
              if [ -n "${REAL}" ]; then
                cp "${REAL}" "${DEST}/${LIB}.so"
              else
                cp -L "${OUT}/${LIB}.so" "${DEST}/${LIB}.so"
              fi
            done
            echo "${ABI}: $(ls -la ${DEST}/)"
          done

          echo ""
          echo "=== Verify shared libs have symbols ==="
          TOOLCHAIN="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin"
          ${TOOLCHAIN}/llvm-nm --dynamic "${OSSL}/arm64-v8a/libcrypto.so" | grep -c "T " || true
          echo "arm64 libcrypto.so exported symbols counted above"

      - name: Create openssl Android.mk
        run: |
          TARGET="ss-full/src/frontends/android/app/src/main/jni/openssl/Android.mk"
          cat > "${TARGET}" << 'ENDOFMK'
          LOCAL_PATH := $(call my-dir)

          # ---- libcrypto (shared prebuilt) ----
          include $(CLEAR_VARS)
          LOCAL_MODULE := libcrypto
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcrypto.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          # ---- backward-compat alias: crypto_static -> libcrypto ----
          # Some strongSwan .mk files reference "crypto_static".
          # We define it as a shared prebuilt pointing to the same .so
          # so those references resolve without patching every file.
          include $(CLEAR_VARS)
          LOCAL_MODULE := crypto_static
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcrypto.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          # ---- libssl (shared prebuilt) ----
          include $(CLEAR_VARS)
          LOCAL_MODULE := libssl
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libssl.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          # ---- backward-compat alias: ssl_static -> libssl ----
          include $(CLEAR_VARS)
          LOCAL_MODULE := ssl_static
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libssl.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)
          ENDOFMK

          # Remove leading whitespace that heredoc indentation adds
          sed -i 's/^          //' "${TARGET}"

          echo "=== openssl/Android.mk ==="
          cat "${TARGET}"

      - name: Patch strongSwan for build
        run: |
          cd ss-full
          JNI_MK="src/frontends/android/app/src/main/jni/Android.mk"
          JNI_DIR="src/frontends/android/app/src/main/jni"

          echo "######################################"
          echo "# PHASE 1: Disable BYOD"
          echo "######################################"
          sed -i 's/^strongswan_USE_BYOD := true/strongswan_USE_BYOD :=/' "${JNI_MK}"

          echo ""
          echo "######################################"
          echo "# PHASE 2: Remove eap-tls from plugins"
          echo "######################################"
          sed -i 's/ eap-tls//' "${JNI_MK}"

          echo ""
          echo "######################################"
          echo "# PHASE 3: Disable BYOD in Java"
          echo "######################################"
          find src/frontends/android -name "*.java" -exec grep -l "USE_BYOD" {} \; | while read f; do
            sed -i 's/USE_BYOD = true/USE_BYOD = false/g' "$f"
          done

          echo ""
          echo "######################################"
          echo "# PHASE 4: Fix ALL .mk files to use"
          echo "#           shared OpenSSL properly"
          echo "######################################"

          # Find every Android.mk under the JNI tree that references crypto_static or ssl_static
          echo "--- Scanning all .mk files for crypto_static / ssl_static references ---"
          find "${JNI_DIR}" -name "*.mk" -exec grep -l "crypto_static\|ssl_static" {} \; 2>/dev/null | while read mkfile; do
            echo ""
            echo "  Patching: ${mkfile}"
            echo "  Before:"
            grep -n "crypto_static\|ssl_static" "${mkfile}" || true

            # Strategy: Move crypto_static/ssl_static from LOCAL_STATIC_LIBRARIES to
            #           LOCAL_SHARED_LIBRARIES as libcrypto/libssl.
            # But since we also define crypto_static as a PREBUILT_SHARED_LIBRARY alias,
            # the safest approach is: change them in LOCAL_STATIC_LIBRARIES to the
            # LOCAL_SHARED_LIBRARIES line. However, this is complex with sed because
            # the variable might be on a continuation line.
            #
            # Simpler approach: Since we defined crypto_static as a shared prebuilt module,
            # we just need to ensure that when it appears in LOCAL_STATIC_LIBRARIES,
            # the NDK treats it correctly. The NDK will actually link it as shared
            # because the module is defined via PREBUILT_SHARED_LIBRARY.
            #
            # BUT: NDK ndk-build may complain if a PREBUILT_SHARED_LIBRARY module
            # is listed in LOCAL_STATIC_LIBRARIES. So let's move them.

            # Move crypto_static from STATIC to SHARED libs
            # Handle both += and := forms, and the reference might just be the name
            sed -i '/LOCAL_STATIC_LIBRARIES.*crypto_static/{
              s/crypto_static//
            }' "${mkfile}"

            sed -i '/LOCAL_STATIC_LIBRARIES.*ssl_static/{
              s/ssl_static//
            }' "${mkfile}"

            # Now add them to LOCAL_SHARED_LIBRARIES
            # We need to find where LOCAL_SHARED_LIBRARIES is set and add our libs.
            # If LOCAL_SHARED_LIBRARIES doesn't exist for this module, we add it
            # before the include $(BUILD_SHARED_LIBRARY) line.

            # Check if this file already has LOCAL_SHARED_LIBRARIES with libcrypto
            if ! grep -q "LOCAL_SHARED_LIBRARIES.*libcrypto" "${mkfile}"; then
              # Insert before BUILD_SHARED_LIBRARY or BUILD_STATIC_LIBRARY
              # Find the right spot - after the LOCAL_STATIC_LIBRARIES block
              if grep -q "LOCAL_SHARED_LIBRARIES" "${mkfile}"; then
                # Append to existing LOCAL_SHARED_LIBRARIES
                sed -i '0,/LOCAL_SHARED_LIBRARIES/{s/LOCAL_SHARED_LIBRARIES\(.*\)/LOCAL_SHARED_LIBRARIES\1 crypto_static ssl_static/}' "${mkfile}"
              else
                # Add a new line before include $(BUILD_
                sed -i '/include \$(BUILD_SHARED_LIBRARY)/i LOCAL_SHARED_LIBRARIES += crypto_static ssl_static' "${mkfile}"
              fi
            fi

            echo "  After:"
            grep -n "crypto_static\|ssl_static\|libcrypto\|libssl\|LOCAL_SHARED_LIBRARIES\|LOCAL_STATIC_LIBRARIES" "${mkfile}" || true
          done

          echo ""
          echo "######################################"
          echo "# PHASE 5: Verify critical files"
          echo "######################################"
          echo ""
          echo "=== src/libstrongswan/Android.mk ==="
          cat src/libstrongswan/Android.mk
          echo ""
          echo "=== Plugins in JNI Android.mk ==="
          grep "strongswan_CHARON_PLUGINS" "${JNI_MK}"
          echo ""
          echo "=== BYOD ==="
          grep "strongswan_USE_BYOD" "${JNI_MK}"

      - name: Diagnostic - dump key files before build
        run: |
          cd ss-full
          JNI_DIR="src/frontends/android/app/src/main/jni"

          echo "============================================"
          echo "=== ALL .mk files referencing openssl/crypto ==="
          echo "============================================"
          find "${JNI_DIR}" -name "*.mk" | while read f; do
            if grep -qi "crypto\|openssl\|ssl" "$f" 2>/dev/null; then
              echo ""
              echo "--- ${f} ---"
              grep -n -i "crypto\|openssl\|ssl\|STATIC_LIBRARIES\|SHARED_LIBRARIES" "$f" || true
            fi
          done

          echo ""
          echo "============================================"
          echo "=== openssl/Android.mk ==="
          echo "============================================"
          cat "${JNI_DIR}/openssl/Android.mk"

          echo ""
          echo "============================================"
          echo "=== Verify .so files exist ==="
          echo "============================================"
          find "${JNI_DIR}/openssl" -name "*.so" -exec ls -la {} \;

          echo ""
          echo "============================================"
          echo "=== Check for symbol EVP_PKEY_free in libs ==="
          echo "============================================"
          TOOLCHAIN="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin"
          for ABI in arm64-v8a armeabi-v7a x86 x86_64; do
            SO="${JNI_DIR}/openssl/${ABI}/libcrypto.so"
            if [ -f "${SO}" ]; then
              COUNT=$(${TOOLCHAIN}/llvm-nm --dynamic "${SO}" 2>/dev/null | grep -c "T EVP_PKEY_free" || true)
              echo "${ABI}: EVP_PKEY_free found ${COUNT} time(s)"
            else
              echo "${ABI}: libcrypto.so MISSING!"
            fi
          done

      - name: Test ndk-build (dry run)
        run: |
          cd ss-full/src/frontends/android/app/src/main/jni
          echo "=== Dry-run ndk-build for arm64-v8a ==="
          ${ANDROID_NDK_HOME}/ndk-build \
            NDK_PROJECT_PATH=null \
            APP_BUILD_SCRIPT=$(pwd)/Android.mk \
            NDK_APPLICATION_MK=$(pwd)/Application.mk \
            APP_ABI=arm64-v8a \
            NDK_DEBUG=1 \
            APP_PLATFORM=android-21 \
            NDK_OUT=/tmp/ndk-out \
            NDK_LIBS_OUT=/tmp/ndk-libs \
            -n -B 2>&1 | tee /tmp/ndk-test.log || true
          echo ""
          echo "=== ERRORS ==="
          grep -i "undefined modules\|depends on\|No such file\|No rule to make\|Stop\.\|cannot find" /tmp/ndk-test.log | head -20 || echo "No critical errors found"
          echo ""
          echo "=== LINK commands ==="
          grep -i "\-lcrypto\|\-lssl\|libcrypto\|libssl" /tmp/ndk-test.log | head -10 || echo "No crypto link references found"

      - name: Build APK
        run: |
          cd ss-full/src/frontends/android
          echo "sdk.dir=${ANDROID_SDK_ROOT}" > local.properties
          sed -i "s|arguments '-j'|arguments 'APP_ALLOW_MISSING_DEPS=true', '-j'|" app/build.gradle
          set +e
          ./gradlew assembleDebug --no-daemon --stacktrace 2>&1 | tee "${GITHUB_WORKSPACE}/build.log"
          RESULT=${PIPESTATUS[0]}
          set -e
          if [ ${RESULT} -ne 0 ]; then
            echo ""
            echo "##############################################"
            echo "# BUILD FAILED - Diagnostics"
            echo "##############################################"
            echo ""
            echo "=== Undefined module errors ==="
            grep -i "undefined modules\|depends on" "${GITHUB_WORKSPACE}/build.log" | head -10
            echo ""
            echo "=== Missing files ==="
            grep -i "No such file\|No rule to make" "${GITHUB_WORKSPACE}/build.log" | grep -v "Exception\|ProcessException" | head -10
            echo ""
            echo "=== C/C++ compile errors ==="
            grep -E "error:" "${GITHUB_WORKSPACE}/build.log" | grep -v "Exception\|ProcessException\|CXX1429\|error when building\|IssueReporter\|TaskExecution\|EventFiring\|DefaultBuild" | head -20
            echo ""
            echo "=== Linker errors ==="
            grep "undefined reference\|undefined symbol\|cannot find -l\|recompile with -fPIC" "${GITHUB_WORKSPACE}/build.log" | head -20
            echo ""
            echo "=== Full context around first error ==="
            grep -n -B5 -A5 "undefined symbol\|undefined reference\|undefined modules" "${GITHUB_WORKSPACE}/build.log" | head -60
            exit 1
          fi

      - name: Upload APK
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: strongswan-debug-apk
          path: ss-full/src/frontends/android/app/build/outputs/apk/debug/*.apk
          if-no-files-found: error

      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          if-no-files-found: warn
