name: Build strongSwan APK

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  OPENSSL_VERSION: "3.3.1"
  NDK_VERSION: "27.3.13750724"
  # === GeckoVPN Branding ===
  CUSTOM_PACKAGE: "com.geckovpn.client"
  CUSTOM_APP_NAME: "GeckoVPN"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y autoconf automake libtool pkg-config gettext python3 bison flex gperf perl curl unzip git libssl-dev libgmp-dev

      - name: Set environment
        run: |
          echo "ANDROID_NDK_HOME=/usr/local/lib/android/sdk/ndk/${{ env.NDK_VERSION }}" >> $GITHUB_ENV
          echo "ANDROID_SDK_ROOT=/usr/local/lib/android/sdk" >> $GITHUB_ENV

      - name: Clone strongSwan
        run: git clone --depth 1 https://github.com/strongswan/strongswan.git ss-full

      - name: Generate strongSwan source files
        run: |
          cd ss-full
          ./autogen.sh
          ./configure \
            --enable-openssl \
            --enable-eap-identity \
            --enable-eap-mschapv2 \
            --enable-eap-md5 \
            --enable-eap-gtc \
            --enable-eap-tls \
            --enable-eap-ttls \
            --enable-eap-tnc
          make -j$(nproc) 2>&1 | tail -20 || echo "Host make done"
          if [ ! -f src/libstrongswan/asn1/oid.c ]; then
            cd src/libstrongswan/asn1 && perl oid.pl oid.txt oid.c oid.h && cd ../../..
          fi
          if [ ! -f Android.common.mk ]; then
            VERSION=$(sed -n "s/^PACKAGE_VERSION='\(.*\)'/\1/p" configure | head -1)
            echo "strongswan_VERSION := ${VERSION}" > Android.common.mk
          fi

      - name: Download OpenSSL
        run: |
          curl -fL -o openssl.tar.gz "https://www.openssl.org/source/openssl-${{ env.OPENSSL_VERSION }}.tar.gz"
          tar xzf openssl.tar.gz

      - name: Build OpenSSL for Android
        run: |
          set -e
          export ANDROID_NDK_ROOT="${ANDROID_NDK_HOME}"
          export PATH="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin:${PATH}"

          build_ssl() {
            local ABI=$1 TARGET=$2
            echo "===== Building OpenSSL for ${ABI} ====="
            local BUILD_DIR="${GITHUB_WORKSPACE}/openssl-build-${ABI}"
            local OUT_DIR="${GITHUB_WORKSPACE}/openssl-out-${ABI}"
            rm -rf "${BUILD_DIR}" "${OUT_DIR}"
            cp -r "openssl-${{ env.OPENSSL_VERSION }}" "${BUILD_DIR}"
            cd "${BUILD_DIR}"
            ./Configure "${TARGET}" \
              -D__ANDROID_API__=21 \
              --prefix="${OUT_DIR}" \
              --openssldir="${OUT_DIR}" \
              --libdir=lib \
              no-tests no-ui-console
            make -j$(nproc)
            make install_sw
            cd "${GITHUB_WORKSPACE}"
          }

          build_ssl arm64-v8a android-arm64
          build_ssl armeabi-v7a android-arm
          build_ssl x86 android-x86
          build_ssl x86_64 android-x86_64

      - name: Setup OpenSSL in JNI directory
        run: |
          set -e
          OSSL="ss-full/src/frontends/android/app/src/main/jni/openssl"
          mkdir -p "${OSSL}/include"
          cp -r "${GITHUB_WORKSPACE}/openssl-out-arm64-v8a/include/openssl" "${OSSL}/include/"

          for ABI in arm64-v8a armeabi-v7a x86 x86_64; do
            DEST="${OSSL}/${ABI}"
            mkdir -p "${DEST}"
            OUT="${GITHUB_WORKSPACE}/openssl-out-${ABI}/lib"
            for LIB in libcrypto libssl; do
              REAL=$(find "${OUT}" -name "${LIB}.so*" ! -type l 2>/dev/null | head -1)
              if [ -n "${REAL}" ]; then
                cp "${REAL}" "${DEST}/${LIB}.so"
              else
                cp -L "${OUT}/${LIB}.so" "${DEST}/${LIB}.so"
              fi
            done
            echo "${ABI}: $(ls -la ${DEST}/)"
          done

      - name: Create openssl Android.mk
        run: |
          TARGET="ss-full/src/frontends/android/app/src/main/jni/openssl/Android.mk"
          cat > "${TARGET}" << 'ENDOFMK'
          LOCAL_PATH := $(call my-dir)

          include $(CLEAR_VARS)
          LOCAL_MODULE := libcrypto
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcrypto.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          include $(CLEAR_VARS)
          LOCAL_MODULE := crypto_static
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcrypto.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          include $(CLEAR_VARS)
          LOCAL_MODULE := libssl
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libssl.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)

          include $(CLEAR_VARS)
          LOCAL_MODULE := ssl_static
          LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libssl.so
          LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
          include $(PREBUILT_SHARED_LIBRARY)
          ENDOFMK
          sed -i 's/^          //' "${TARGET}"

      - name: Patch strongSwan for build
        run: |
          cd ss-full
          JNI_MK="src/frontends/android/app/src/main/jni/Android.mk"
          JNI_DIR="src/frontends/android/app/src/main/jni"

          echo "=== 1. Disable BYOD ==="
          sed -i 's/^strongswan_USE_BYOD := true/strongswan_USE_BYOD :=/' "${JNI_MK}"

          echo "=== 2. Remove eap-tls from plugins ==="
          sed -i 's/ eap-tls//' "${JNI_MK}"

          echo "=== 3. Disable BYOD in Java ==="
          find src/frontends/android -name "*.java" -exec grep -l "USE_BYOD" {} \; | while read f; do
            sed -i 's/USE_BYOD = true/USE_BYOD = false/g' "$f"
          done

          echo "=== 4. Fix OpenSSL references in all .mk files ==="
          find "${JNI_DIR}" -name "*.mk" -exec grep -l "crypto_static\|ssl_static" {} \; 2>/dev/null | while read mkfile; do
            echo "  Patching: ${mkfile}"
            sed -i '/LOCAL_STATIC_LIBRARIES.*crypto_static/{
              s/crypto_static//
            }' "${mkfile}"
            sed -i '/LOCAL_STATIC_LIBRARIES.*ssl_static/{
              s/ssl_static//
            }' "${mkfile}"
            if ! grep -q "LOCAL_SHARED_LIBRARIES.*crypto_static" "${mkfile}"; then
              if grep -q "LOCAL_SHARED_LIBRARIES" "${mkfile}"; then
                sed -i '0,/LOCAL_SHARED_LIBRARIES/{s/LOCAL_SHARED_LIBRARIES\(.*\)/LOCAL_SHARED_LIBRARIES\1 crypto_static ssl_static/}' "${mkfile}"
              else
                sed -i '/include \$(BUILD_SHARED_LIBRARY)/i LOCAL_SHARED_LIBRARIES += crypto_static ssl_static' "${mkfile}"
              fi
            fi
          done

      - name: Rebrand as GeckoVPN (package + identity)
        run: |
          cd ss-full/src/frontends/android
          ANDROID_DIR="$(pwd)"
          OLD_PKG="org.strongswan.android"
          NEW_PKG="${CUSTOM_PACKAGE}"
          OLD_PATH="org/strongswan/android"
          NEW_PATH="com/geckovpn/client"

          echo "============================================"
          echo "=== Rebranding: ${OLD_PKG} -> ${NEW_PKG}"
          echo "============================================"

          echo ""
          echo "--- 1. Update build.gradle applicationId ---"
          # Change applicationId in app/build.gradle
          sed -i "s|applicationId \"${OLD_PKG}\"|applicationId \"${NEW_PKG}\"|g" app/build.gradle
          # Also handle namespace
          sed -i "s|namespace \"${OLD_PKG}\"|namespace \"${NEW_PKG}\"|g" app/build.gradle
          # Verify
          echo "build.gradle changes:"
          grep -n "applicationId\|namespace" app/build.gradle

          echo ""
          echo "--- 2. Update AndroidManifest.xml ---"
          find . -name "AndroidManifest.xml" | while read manifest; do
            sed -i "s|${OLD_PKG}|${NEW_PKG}|g" "${manifest}"
            echo "Updated: ${manifest}"
          done

          echo ""
          echo "--- 3. Update all Java/Kotlin source imports ---"
          find . -name "*.java" -o -name "*.kt" | while read src; do
            if grep -q "${OLD_PKG}" "${src}" 2>/dev/null; then
              sed -i "s|${OLD_PKG}|${NEW_PKG}|g" "${src}"
            fi
          done

          echo ""
          echo "--- 4. Update XML resources ---"
          find . -name "*.xml" | while read xml; do
            if grep -q "${OLD_PKG}" "${xml}" 2>/dev/null; then
              sed -i "s|${OLD_PKG}|${NEW_PKG}|g" "${xml}"
            fi
          done

          echo ""
          echo "--- 5. Update AIDL files ---"
          find . -name "*.aidl" | while read aidl; do
            if grep -q "${OLD_PKG}" "${aidl}" 2>/dev/null; then
              sed -i "s|${OLD_PKG}|${NEW_PKG}|g" "${aidl}"
            fi
          done

          echo ""
          echo "--- 6. Move Java source directories ---"
          # We need to move the actual source tree to match new package
          for SRC_SET in main androidTest test; do
            OLD_DIR="app/src/${SRC_SET}/java/${OLD_PATH}"
            NEW_DIR="app/src/${SRC_SET}/java/${NEW_PATH}"
            if [ -d "${OLD_DIR}" ]; then
              mkdir -p "${NEW_DIR}"
              cp -r "${OLD_DIR}"/* "${NEW_DIR}/" 2>/dev/null || true
              rm -rf "app/src/${SRC_SET}/java/org/strongswan"
              echo "Moved: ${OLD_DIR} -> ${NEW_DIR}"
            fi
          done

          echo ""
          echo "--- 7. Move AIDL directories ---"
          for SRC_SET in main; do
            OLD_DIR="app/src/${SRC_SET}/aidl/${OLD_PATH}"
            NEW_DIR="app/src/${SRC_SET}/aidl/${NEW_PATH}"
            if [ -d "${OLD_DIR}" ]; then
              mkdir -p "${NEW_DIR}"
              cp -r "${OLD_DIR}"/* "${NEW_DIR}/" 2>/dev/null || true
              rm -rf "app/src/${SRC_SET}/aidl/org/strongswan"
              echo "Moved: ${OLD_DIR} -> ${NEW_DIR}"
            fi
          done

          echo ""
          echo "--- 8. Update app_name in strings.xml ---"
          find . -name "strings.xml" | while read str; do
            sed -i "s|<string name=\"app_name\">strongSwan VPN Client</string>|<string name=\"app_name\">${CUSTOM_APP_NAME}</string>|g" "${str}"
            sed -i "s|strongSwan VPN Client|${CUSTOM_APP_NAME}|g" "${str}"
            sed -i "s|strongSwan|${CUSTOM_APP_NAME}|g" "${str}"
          done

          echo ""
          echo "--- 9. Update JNI references ---"
          # The C code in JNI uses JNI function names with the package path
          # e.g., Java_org_strongswan_android_logic_...
          OLD_JNI="Java_org_strongswan_android"
          NEW_JNI="Java_com_geckovpn_client"
          find ../../../ -name "*.c" -o -name "*.h" | while read cfile; do
            if grep -q "${OLD_JNI}" "${cfile}" 2>/dev/null; then
              sed -i "s|${OLD_JNI}|${NEW_JNI}|g" "${cfile}"
              echo "JNI updated: ${cfile}"
            fi
          done

          echo ""
          echo "--- 10. Update content provider authorities ---"
          # Content providers use the package name as authority
          find . -name "*.xml" -o -name "*.java" -o -name "*.kt" | while read f; do
            if grep -q "org\.strongswan\.android" "${f}" 2>/dev/null; then
              sed -i "s|org\.strongswan\.android|com.geckovpn.client|g" "${f}"
            fi
          done

          echo ""
          echo "--- 11. Update Gradle settings if needed ---"
          if [ -f "settings.gradle" ]; then
            sed -i "s|${OLD_PKG}|${NEW_PKG}|g" settings.gradle
          fi

          echo ""
          echo "--- Verification ---"
          echo "Remaining references to old package:"
          REMAINING=$(grep -r "org.strongswan.android" --include="*.java" --include="*.kt" --include="*.xml" --include="*.aidl" --include="*.gradle" . 2>/dev/null | grep -v "Binary\|\.git\|build/" | wc -l)
          echo "  Count: ${REMAINING}"
          if [ "${REMAINING}" -gt 0 ]; then
            grep -r "org.strongswan.android" --include="*.java" --include="*.kt" --include="*.xml" --include="*.aidl" --include="*.gradle" . 2>/dev/null | grep -v "Binary\|\.git\|build/" | head -20
          fi

          echo ""
          echo "JNI function names check:"
          grep -r "Java_org_strongswan" ../../../ --include="*.c" --include="*.h" 2>/dev/null | head -5 || echo "All JNI names updated!"

      - name: Add GeckoVPN custom UI and profile system
        run: |
          cd ss-full/src/frontends/android
          NEW_PATH="com/geckovpn/client"
          JAVA_DIR="app/src/main/java/${NEW_PATH}"

          echo "=== Creating GeckoVPN Profile System ==="

          # --- ProfileCrypto.java ---
          cat > "${JAVA_DIR}/logic/ProfileCrypto.java" << 'JAVA_EOF'
          package com.geckovpn.client.logic;

          import android.util.Base64;
          import java.nio.charset.StandardCharsets;
          import java.security.MessageDigest;
          import javax.crypto.Cipher;
          import javax.crypto.spec.GCMParameterSpec;
          import javax.crypto.spec.SecretKeySpec;
          import org.json.JSONArray;
          import org.json.JSONObject;

          public class ProfileCrypto {

              // This key is compiled into the app - profiles are encrypted with it
              // In production you'd fetch this or derive it more securely
              private static final String MASTER_KEY = "G3ck0VPN-2024!SecretKey#Encrypt";

              public static class ProfileData {
                  public String username;
                  public String password;
                  public String[] servers;       // server addresses
                  public String[] serverNames;   // display names
                  public long expiryTimestamp;    // Unix millis when profile expires
                  public String profileId;       // unique ID
                  public String updateUrl;       // URL to fetch server list updates

                  public boolean isExpired() {
                      return System.currentTimeMillis() > expiryTimestamp;
                  }

                  public int remainingDays() {
                      long diff = expiryTimestamp - System.currentTimeMillis();
                      if (diff <= 0) return 0;
                      return (int)(diff / (1000L * 60 * 60 * 24));
                  }
              }

              /**
               * Decrypt an encrypted profile string (base64 encoded)
               */
              public static ProfileData decryptProfile(String encryptedBase64) throws Exception {
                  byte[] encrypted = Base64.decode(encryptedBase64, Base64.DEFAULT | Base64.NO_WRAP);

                  // First 12 bytes = IV, rest = ciphertext + tag
                  byte[] iv = new byte[12];
                  byte[] ciphertext = new byte[encrypted.length - 12];
                  System.arraycopy(encrypted, 0, iv, 0, 12);
                  System.arraycopy(encrypted, 12, ciphertext, 0, ciphertext.length);

                  // Derive key from master key
                  MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
                  byte[] keyBytes = sha256.digest(MASTER_KEY.getBytes(StandardCharsets.UTF_8));
                  SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");

                  Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                  GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
                  cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec);

                  byte[] plaintext = cipher.doFinal(ciphertext);
                  String json = new String(plaintext, StandardCharsets.UTF_8);

                  return parseProfile(json);
              }

              /**
               * Parse a JSON profile
               */
              public static ProfileData parseProfile(String json) throws Exception {
                  JSONObject obj = new JSONObject(json);
                  ProfileData data = new ProfileData();
                  data.profileId = obj.getString("id");
                  data.username = obj.getString("username");
                  data.password = obj.getString("password");
                  data.expiryTimestamp = obj.getLong("expiry");

                  // Optional update URL
                  data.updateUrl = obj.optString("updateUrl", "");

                  JSONArray serversArr = obj.getJSONArray("servers");
                  data.servers = new String[serversArr.length()];
                  data.serverNames = new String[serversArr.length()];
                  for (int i = 0; i < serversArr.length(); i++) {
                      JSONObject s = serversArr.getJSONObject(i);
                      data.servers[i] = s.getString("addr");
                      data.serverNames[i] = s.optString("name", data.servers[i]);
                  }

                  return data;
              }

              /**
               * Encrypt a profile JSON string (for profile generator tool)
               */
              public static String encryptProfile(String json) throws Exception {
                  MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
                  byte[] keyBytes = sha256.digest(MASTER_KEY.getBytes(StandardCharsets.UTF_8));
                  SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");

                  Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                  cipher.init(Cipher.ENCRYPT_MODE, keySpec);

                  byte[] iv = cipher.getIV();
                  byte[] ciphertext = cipher.doFinal(json.getBytes(StandardCharsets.UTF_8));

                  // Combine IV + ciphertext
                  byte[] combined = new byte[iv.length + ciphertext.length];
                  System.arraycopy(iv, 0, combined, 0, iv.length);
                  System.arraycopy(ciphertext, 0, combined, iv.length, ciphertext.length);

                  return Base64.encodeToString(combined, Base64.NO_WRAP);
              }
          }
          JAVA_EOF

          # --- ProfileManager.java ---
          cat > "${JAVA_DIR}/logic/ProfileManager.java" << 'JAVA_EOF'
          package com.geckovpn.client.logic;

          import android.content.Context;
          import android.content.SharedPreferences;
          import android.util.Log;
          import org.json.JSONObject;
          import java.io.BufferedReader;
          import java.io.InputStreamReader;
          import java.net.HttpURLConnection;
          import java.net.URL;

          public class ProfileManager {
              private static final String TAG = "GeckoVPN";
              private static final String PREFS_NAME = "geckovpn_profiles";
              private static final String KEY_PROFILE = "active_profile";
              private static final String KEY_ENCRYPTED = "encrypted_data";
              private static final String KEY_LAST_UPDATE = "last_update_check";
              private static final long UPDATE_INTERVAL = 2 * 24 * 60 * 60 * 1000L; // 2 days

              private final Context context;
              private final SharedPreferences prefs;

              public ProfileManager(Context context) {
                  this.context = context;
                  this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
              }

              /**
               * Import an encrypted profile string
               */
              public ProfileCrypto.ProfileData importProfile(String encryptedData) throws Exception {
                  ProfileCrypto.ProfileData data = ProfileCrypto.decryptProfile(encryptedData);

                  // Store encrypted data
                  prefs.edit()
                      .putString(KEY_ENCRYPTED, encryptedData)
                      .putString(KEY_PROFILE, dataToJson(data))
                      .putLong(KEY_LAST_UPDATE, System.currentTimeMillis())
                      .apply();

                  Log.i(TAG, "Profile imported: " + data.profileId +
                        ", servers: " + data.servers.length +
                        ", expires in " + data.remainingDays() + " days");

                  return data;
              }

              /**
               * Get the active profile (null if none or expired)
               */
              public ProfileCrypto.ProfileData getActiveProfile() {
                  String json = prefs.getString(KEY_PROFILE, null);
                  if (json == null) return null;
                  try {
                      return ProfileCrypto.parseProfile(json);
                  } catch (Exception e) {
                      Log.e(TAG, "Failed to parse stored profile", e);
                      return null;
                  }
              }

              /**
               * Check if profile exists
               */
              public boolean hasProfile() {
                  return prefs.getString(KEY_PROFILE, null) != null;
              }

              /**
               * Clear the profile
               */
              public void clearProfile() {
                  prefs.edit().clear().apply();
              }

              /**
               * Check if server list needs refresh and do it in background
               */
              public void checkForUpdates(UpdateCallback callback) {
                  ProfileCrypto.ProfileData data = getActiveProfile();
                  if (data == null || data.updateUrl == null || data.updateUrl.isEmpty()) {
                      return;
                  }

                  long lastUpdate = prefs.getLong(KEY_LAST_UPDATE, 0);
                  if (System.currentTimeMillis() - lastUpdate < UPDATE_INTERVAL) {
                      return; // Too soon
                  }

                  new Thread(() -> {
                      try {
                          URL url = new URL(data.updateUrl);
                          HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                          conn.setConnectTimeout(10000);
                          conn.setReadTimeout(10000);

                          BufferedReader reader = new BufferedReader(
                              new InputStreamReader(conn.getInputStream()));
                          StringBuilder sb = new StringBuilder();
                          String line;
                          while ((line = reader.readLine()) != null) {
                              sb.append(line);
                          }
                          reader.close();

                          String newEncrypted = sb.toString().trim();
                          ProfileCrypto.ProfileData newData = ProfileCrypto.decryptProfile(newEncrypted);

                          // Keep original expiry - server can't extend time
                          newData.expiryTimestamp = data.expiryTimestamp;
                          newData.username = data.username;
                          newData.password = data.password;

                          prefs.edit()
                              .putString(KEY_PROFILE, dataToJson(newData))
                              .putLong(KEY_LAST_UPDATE, System.currentTimeMillis())
                              .apply();

                          Log.i(TAG, "Server list updated: " + newData.servers.length + " servers");
                          if (callback != null) callback.onUpdated(newData);

                      } catch (Exception e) {
                          Log.w(TAG, "Update check failed", e);
                          if (callback != null) callback.onError(e);
                      }
                  }).start();
              }

              private String dataToJson(ProfileCrypto.ProfileData data) {
                  try {
                      JSONObject obj = new JSONObject();
                      obj.put("id", data.profileId);
                      obj.put("username", data.username);
                      obj.put("password", data.password);
                      obj.put("expiry", data.expiryTimestamp);
                      obj.put("updateUrl", data.updateUrl != null ? data.updateUrl : "");
                      org.json.JSONArray servers = new org.json.JSONArray();
                      for (int i = 0; i < data.servers.length; i++) {
                          JSONObject s = new JSONObject();
                          s.put("addr", data.servers[i]);
                          s.put("name", data.serverNames[i]);
                          servers.put(s);
                      }
                      obj.put("servers", servers);
                      return obj.toString();
                  } catch (Exception e) {
                      return "{}";
                  }
              }

              public interface UpdateCallback {
                  void onUpdated(ProfileCrypto.ProfileData newData);
                  void onError(Exception e);
              }
          }
          JAVA_EOF

          # --- FastServerSelector.java ---
          cat > "${JAVA_DIR}/logic/FastServerSelector.java" << 'JAVA_EOF'
          package com.geckovpn.client.logic;

          import android.util.Log;
          import java.net.InetAddress;
          import java.util.ArrayList;
          import java.util.List;
          import java.util.concurrent.Callable;
          import java.util.concurrent.ExecutorService;
          import java.util.concurrent.Executors;
          import java.util.concurrent.Future;
          import java.util.concurrent.TimeUnit;

          /**
           * Quickly finds the fastest server by pinging a subset.
           * Does NOT test all servers - tests up to MAX_TEST servers concurrently,
           * returns the first one that responds (fastest).
           */
          public class FastServerSelector {
              private static final String TAG = "GeckoVPN";
              private static final int MAX_TEST = 5;        // Test at most 5 servers
              private static final int TIMEOUT_MS = 2000;   // 2 second timeout per ping

              public static class ServerResult {
                  public String address;
                  public String name;
                  public long latencyMs;
              }

              /**
               * Find the fastest server from the list.
               * Tests up to MAX_TEST servers concurrently, returns quickest responder.
               * If all fail, returns the first server in list (fallback).
               */
              public static ServerResult findFastest(String[] servers, String[] names) {
                  if (servers == null || servers.length == 0) return null;

                  // If only 1 server, just use it
                  if (servers.length == 1) {
                      ServerResult r = new ServerResult();
                      r.address = servers[0];
                      r.name = names[0];
                      r.latencyMs = 0;
                      return r;
                  }

                  // Test up to MAX_TEST servers
                  int testCount = Math.min(servers.length, MAX_TEST);
                  ExecutorService executor = Executors.newFixedThreadPool(testCount);
                  List<Future<ServerResult>> futures = new ArrayList<>();

                  for (int i = 0; i < testCount; i++) {
                      final int idx = i;
                      final String addr = servers[i];
                      final String name = names[i];

                      futures.add(executor.submit(() -> {
                          ServerResult result = new ServerResult();
                          result.address = addr;
                          result.name = name;
                          long start = System.currentTimeMillis();
                          try {
                              InetAddress inet = InetAddress.getByName(addr);
                              boolean reachable = inet.isReachable(TIMEOUT_MS);
                              result.latencyMs = System.currentTimeMillis() - start;
                              if (!reachable) {
                                  result.latencyMs = Long.MAX_VALUE;
                              }
                          } catch (Exception e) {
                              result.latencyMs = Long.MAX_VALUE;
                          }
                          Log.d(TAG, "Ping " + addr + ": " + result.latencyMs + "ms");
                          return result;
                      }));
                  }

                  ServerResult best = null;
                  try {
                      // Wait for all to complete (max 3 seconds total)
                      executor.shutdown();
                      executor.awaitTermination(3, TimeUnit.SECONDS);

                      for (Future<ServerResult> f : futures) {
                          if (f.isDone()) {
                              try {
                                  ServerResult r = f.get();
                                  if (best == null || r.latencyMs < best.latencyMs) {
                                      best = r;
                                  }
                              } catch (Exception ignore) {}
                          }
                      }
                  } catch (InterruptedException e) {
                      Log.w(TAG, "Server selection interrupted");
                  }

                  // Fallback to first server
                  if (best == null || best.latencyMs == Long.MAX_VALUE) {
                      best = new ServerResult();
                      best.address = servers[0];
                      best.name = names[0];
                      best.latencyMs = -1;
                      Log.w(TAG, "All pings failed, using first server: " + best.address);
                  } else {
                      Log.i(TAG, "Fastest server: " + best.address + " (" + best.latencyMs + "ms)");
                  }

                  return best;
              }
          }
          JAVA_EOF

          echo "=== Core logic files created ==="
          ls -la "${JAVA_DIR}/logic/"

      - name: Create GeckoVPN Main Activity
        run: |
          cd ss-full/src/frontends/android
          NEW_PATH="com/geckovpn/client"
          JAVA_DIR="app/src/main/java/${NEW_PATH}"
          RES_DIR="app/src/main/res"

          # --- activity_geckovpn_main.xml ---
          mkdir -p "${RES_DIR}/layout"
          cat > "${RES_DIR}/layout/activity_geckovpn_main.xml" << 'XML_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical"
              android:gravity="center_horizontal"
              android:background="#1a1a2e"
              android:padding="24dp">

              <!-- Logo/Title -->
              <TextView
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="GeckoVPN"
                  android:textSize="32sp"
                  android:textColor="#00d4aa"
                  android:textStyle="bold"
                  android:layout_marginTop="40dp" />

              <!-- Status Text -->
              <TextView
                  android:id="@+id/status_text"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="Disconnected"
                  android:textSize="18sp"
                  android:textColor="#ffffff"
                  android:layout_marginTop="16dp" />

              <!-- Server Name -->
              <TextView
                  android:id="@+id/server_text"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text=""
                  android:textSize="14sp"
                  android:textColor="#aaaaaa"
                  android:layout_marginTop="8dp" />

              <!-- Remaining Days -->
              <TextView
                  android:id="@+id/days_text"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text=""
                  android:textSize="16sp"
                  android:textColor="#ffcc00"
                  android:layout_marginTop="16dp" />

              <!-- Big Connect Button -->
              <Button
                  android:id="@+id/connect_button"
                  android:layout_width="200dp"
                  android:layout_height="200dp"
                  android:layout_marginTop="40dp"
                  android:background="@drawable/circle_button"
                  android:text="CONNECT"
                  android:textSize="20sp"
                  android:textColor="#ffffff"
                  android:textStyle="bold" />

              <!-- Spacer -->
              <View
                  android:layout_width="0dp"
                  android:layout_height="0dp"
                  android:layout_weight="1" />

              <!-- Import Profile Button -->
              <Button
                  android:id="@+id/import_button"
                  android:layout_width="match_parent"
                  android:layout_height="48dp"
                  android:text="Import Profile"
                  android:textColor="#ffffff"
                  android:backgroundTint="#333355"
                  android:layout_marginBottom="8dp" />

              <!-- Scan QR Button -->
              <Button
                  android:id="@+id/scan_button"
                  android:layout_width="match_parent"
                  android:layout_height="48dp"
                  android:text="Scan QR Code"
                  android:textColor="#ffffff"
                  android:backgroundTint="#333355"
                  android:layout_marginBottom="16dp" />

          </LinearLayout>
          XML_EOF

          # --- dialog_import_profile.xml ---
          cat > "${RES_DIR}/layout/dialog_import_profile.xml" << 'XML_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:orientation="vertical"
              android:padding="24dp">

              <TextView
                  android:layout_width="match_parent"
                  android:layout_height="wrap_content"
                  android:text="Paste your encrypted profile code below:"
                  android:textSize="14sp"
                  android:layout_marginBottom="12dp" />

              <EditText
                  android:id="@+id/profile_input"
                  android:layout_width="match_parent"
                  android:layout_height="120dp"
                  android:hint="Paste encrypted profile here..."
                  android:gravity="top"
                  android:inputType="textMultiLine"
                  android:background="#f0f0f0"
                  android:padding="8dp" />

          </LinearLayout>
          XML_EOF

          # --- circle_button.xml (drawable) ---
          mkdir -p "${RES_DIR}/drawable"
          cat > "${RES_DIR}/drawable/circle_button.xml" << 'XML_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <selector xmlns:android="http://schemas.android.com/apk/res/android">
              <item android:state_pressed="true">
                  <shape android:shape="oval">
                      <solid android:color="#008866" />
                      <stroke android:width="3dp" android:color="#00d4aa" />
                  </shape>
              </item>
              <item>
                  <shape android:shape="oval">
                      <solid android:color="#00aa88" />
                      <stroke android:width="3dp" android:color="#00d4aa" />
                  </shape>
              </item>
          </selector>
          XML_EOF

          # --- circle_button_connected.xml ---
          cat > "${RES_DIR}/drawable/circle_button_connected.xml" << 'XML_EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <selector xmlns:android="http://schemas.android.com/apk/res/android">
              <item android:state_pressed="true">
                  <shape android:shape="oval">
                      <solid android:color="#cc3333" />
                      <stroke android:width="3dp" android:color="#ff4444" />
                  </shape>
              </item>
              <item>
                  <shape android:shape="oval">
                      <solid android:color="#dd4444" />
                      <stroke android:width="3dp" android:color="#ff4444" />
                  </shape>
              </item>
          </selector>
          XML_EOF

          echo "=== UI resources created ==="

          # --- GeckoMainActivity.java ---
          cat > "${JAVA_DIR}/ui/GeckoMainActivity.java" << 'JAVA_EOF'
          package com.geckovpn.client.ui;

          import android.app.Activity;
          import android.app.AlertDialog;
          import android.content.ComponentName;
          import android.content.Context;
          import android.content.Intent;
          import android.content.ServiceConnection;
          import android.net.VpnService;
          import android.os.Bundle;
          import android.os.IBinder;
          import android.util.Log;
          import android.view.View;
          import android.widget.Button;
          import android.widget.EditText;
          import android.widget.TextView;
          import android.widget.Toast;

          import com.geckovpn.client.R;
          import com.geckovpn.client.logic.FastServerSelector;
          import com.geckovpn.client.logic.ProfileCrypto;
          import com.geckovpn.client.logic.ProfileManager;

          import org.strongswan.android.logic.CharonVpnService;
          import org.strongswan.android.data.VpnProfile;
          import org.strongswan.android.data.VpnProfileDataSource;
          import org.strongswan.android.data.VpnType;

          import java.util.UUID;

          public class GeckoMainActivity extends Activity {
              private static final String TAG = "GeckoVPN";
              private static final int VPN_REQUEST_CODE = 100;

              private Button connectButton;
              private Button importButton;
              private Button scanButton;
              private TextView statusText;
              private TextView serverText;
              private TextView daysText;

              private ProfileManager profileManager;
              private boolean isConnected = false;
              private boolean isConnecting = false;
              private ProfileCrypto.ProfileData activeProfile;

              @Override
              protected void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  setContentView(R.layout.activity_geckovpn_main);

                  connectButton = findViewById(R.id.connect_button);
                  importButton = findViewById(R.id.import_button);
                  scanButton = findViewById(R.id.scan_button);
                  statusText = findViewById(R.id.status_text);
                  serverText = findViewById(R.id.server_text);
                  daysText = findViewById(R.id.days_text);

                  profileManager = new ProfileManager(this);

                  connectButton.setOnClickListener(v -> onConnectClicked());
                  importButton.setOnClickListener(v -> showImportDialog());
                  scanButton.setOnClickListener(v -> startQrScanner());

                  refreshUI();

                  // Check for server list updates
                  profileManager.checkForUpdates(new ProfileManager.UpdateCallback() {
                      @Override
                      public void onUpdated(ProfileCrypto.ProfileData newData) {
                          runOnUiThread(() -> {
                              activeProfile = newData;
                              refreshUI();
                              Toast.makeText(GeckoMainActivity.this,
                                  "Server list updated!", Toast.LENGTH_SHORT).show();
                          });
                      }
                      @Override
                      public void onError(Exception e) {
                          Log.w(TAG, "Update check failed: " + e.getMessage());
                      }
                  });
              }

              @Override
              protected void onResume() {
                  super.onResume();
                  refreshUI();
              }

              private void refreshUI() {
                  activeProfile = profileManager.getActiveProfile();

                  if (activeProfile == null) {
                      statusText.setText("No Profile");
                      daysText.setText("Import a profile to get started");
                      serverText.setText("");
                      connectButton.setText("NO\nPROFILE");
                      connectButton.setEnabled(false);
                      connectButton.setBackgroundResource(R.drawable.circle_button);
                      return;
                  }

                  if (activeProfile.isExpired()) {
                      statusText.setText("Profile Expired");
                      daysText.setText("0 days remaining");
                      serverText.setText("");
                      connectButton.setText("EXPIRED");
                      connectButton.setEnabled(false);
                      connectButton.setBackgroundResource(R.drawable.circle_button);
                      showExpiredDialog();
                      return;
                  }

                  int days = activeProfile.remainingDays();
                  daysText.setText(days + " day" + (days != 1 ? "s" : "") + " remaining");

                  if (isConnected) {
                      statusText.setText("Connected");
                      connectButton.setText("DISCONNECT");
                      connectButton.setBackgroundResource(R.drawable.circle_button_connected);
                      connectButton.setEnabled(true);
                  } else if (isConnecting) {
                      statusText.setText("Connecting...");
                      connectButton.setText("...");
                      connectButton.setEnabled(false);
                  } else {
                      statusText.setText("Disconnected");
                      connectButton.setText("CONNECT");
                      connectButton.setBackgroundResource(R.drawable.circle_button);
                      connectButton.setEnabled(true);
                      serverText.setText(activeProfile.servers.length + " servers available");
                  }
              }

              private void onConnectClicked() {
                  if (activeProfile == null) {
                      showImportDialog();
                      return;
                  }

                  if (activeProfile.isExpired()) {
                      showExpiredDialog();
                      return;
                  }

                  if (isConnected) {
                      disconnect();
                  } else {
                      connect();
                  }
              }

              private void connect() {
                  isConnecting = true;
                  refreshUI();

                  // Find fastest server in background
                  new Thread(() -> {
                      FastServerSelector.ServerResult fastest =
                          FastServerSelector.findFastest(activeProfile.servers, activeProfile.serverNames);

                      if (fastest == null) {
                          runOnUiThread(() -> {
                              isConnecting = false;
                              refreshUI();
                              Toast.makeText(this, "No servers available", Toast.LENGTH_SHORT).show();
                          });
                          return;
                      }

                      runOnUiThread(() -> {
                          serverText.setText("â†’ " + fastest.name);
                          startVpnConnection(fastest.address);
                      });
                  }).start();
              }

              private void startVpnConnection(String serverAddress) {
                  // Request VPN permission if needed
                  Intent intent = VpnService.prepare(this);
                  if (intent != null) {
                      startActivityForResult(intent, VPN_REQUEST_CODE);
                      // Store server for after permission
                      getIntent().putExtra("pending_server", serverAddress);
                      return;
                  }

                  launchCharonVpn(serverAddress);
              }

              @Override
              protected void onActivityResult(int requestCode, int resultCode, Intent data) {
                  super.onActivityResult(requestCode, resultCode, data);
                  if (requestCode == VPN_REQUEST_CODE && resultCode == RESULT_OK) {
                      String server = getIntent().getStringExtra("pending_server");
                      if (server != null) {
                          launchCharonVpn(server);
                      }
                  } else {
                      isConnecting = false;
                      refreshUI();
                  }
              }

              private void launchCharonVpn(String serverAddress) {
                  try {
                      // Create a VPN profile and start the service
                      VpnProfileDataSource dataSource = new VpnProfileDataSource(this);
                      dataSource.open();

                      // Remove old GeckoVPN profiles
                      // Create new profile
                      VpnProfile profile = new VpnProfile();
                      profile.setName("GeckoVPN - " + serverAddress);
                      profile.setGateway(serverAddress);
                      profile.setUsername(activeProfile.username);
                      profile.setPassword(activeProfile.password);
                      profile.setVpnType(VpnType.IKEV2_EAP);

                      VpnProfile saved = dataSource.insertProfile(profile);
                      dataSource.close();

                      // Start CharonVpnService
                      Intent intent = new Intent(this, CharonVpnService.class);
                      intent.putExtra(CharonVpnService.PROFILE_UUID, saved.getUUID().toString());
                      startService(intent);

                      isConnecting = false;
                      isConnected = true;
                      refreshUI();

                  } catch (Exception e) {
                      Log.e(TAG, "Failed to start VPN", e);
                      isConnecting = false;
                      refreshUI();
                      Toast.makeText(this, "Connection failed: " + e.getMessage(),
                          Toast.LENGTH_LONG).show();
                  }
              }

              private void disconnect() {
                  // Stop CharonVpnService
                  Intent intent = new Intent(this, CharonVpnService.class);
                  stopService(intent);

                  isConnected = false;
                  isConnecting = false;
                  serverText.setText("");
                  refreshUI();
              }

              private void showImportDialog() {
                  View dialogView = getLayoutInflater().inflate(R.layout.dialog_import_profile, null);
                  EditText input = dialogView.findViewById(R.id.profile_input);

                  new AlertDialog.Builder(this)
                      .setTitle("Import Profile")
                      .setView(dialogView)
                      .setPositiveButton("Import", (dialog, which) -> {
                          String text = input.getText().toString().trim();
                          if (text.isEmpty()) {
                              Toast.makeText(this, "Please paste a profile code",
                                  Toast.LENGTH_SHORT).show();
                              return;
                          }
                          importProfile(text);
                      })
                      .setNegativeButton("Cancel", null)
                      .show();
              }

              private void importProfile(String encryptedData) {
                  try {
                      activeProfile = profileManager.importProfile(encryptedData);

                      if (activeProfile.isExpired()) {
                          showExpiredDialog();
                          return;
                      }

                      Toast.makeText(this, "Profile imported! " +
                          activeProfile.servers.length + " servers, " +
                          activeProfile.remainingDays() + " days remaining",
                          Toast.LENGTH_LONG).show();

                      refreshUI();

                  } catch (Exception e) {
                      Log.e(TAG, "Import failed", e);
                      Toast.makeText(this, "Invalid profile code: " + e.getMessage(),
                          Toast.LENGTH_LONG).show();
                  }
              }

              private void startQrScanner() {
                  // Simple approach: use intent to scan
                  try {
                      Intent intent = new Intent("com.google.zxing.client.android.SCAN");
                      intent.putExtra("SCAN_MODE", "QR_CODE_MODE");
                      startActivityForResult(intent, 200);
                  } catch (Exception e) {
                      // ZXing not installed, show a message
                      Toast.makeText(this,
                          "Please install a QR scanner app, or paste the code manually",
                          Toast.LENGTH_LONG).show();
                  }
              }

              private void showExpiredDialog() {
                  new AlertDialog.Builder(this)
                      .setTitle("Subscription Expired")
                      .setMessage("Your VPN subscription has expired.\n\n" +
                          "To renew your subscription, please contact support.")
                      .setPositiveButton("Contact Support", (dialog, which) -> {
                          Intent intent = new Intent(Intent.ACTION_VIEW,
                              android.net.Uri.parse("https://t.me/vpnproxytestsupport"));
                          startActivity(intent);
                      })
                      .setNegativeButton("Close", null)
                      .setCancelable(false)
                      .show();
              }
          }
          JAVA_EOF

          echo "=== GeckoMainActivity.java created ==="

      - name: Patch AndroidManifest for GeckoVPN
        run: |
          cd ss-full/src/frontends/android
          MANIFEST="app/src/main/AndroidManifest.xml"

          echo "=== Patching AndroidManifest.xml ==="

          # Add INTERNET permission if not present
          if ! grep -q "android.permission.INTERNET" "${MANIFEST}"; then
            sed -i '/<manifest/a\    <uses-permission android:name="android.permission.INTERNET" />' "${MANIFEST}"
          fi

          # Replace the main launcher activity
          # Find the current activity with LAUNCHER intent filter and change it
          # We'll add our activity and remove LAUNCHER from the old one

          # First, add our GeckoMainActivity before the closing </application>
          ACTIVITY_BLOCK='
                  <activity
                      android:name="com.geckovpn.client.ui.GeckoMainActivity"
                      android:label="GeckoVPN"
                      android:theme="@style/Theme.AppCompat.NoActionBar"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>'

          # Remove LAUNCHER category from existing activities
          # Use python for complex XML manipulation
          python3 << 'PYEOF'
          import re

          with open("app/src/main/AndroidManifest.xml", "r") as f:
              content = f.read()

          # Remove existing LAUNCHER intent-filters (but keep the activities)
          # We want to remove just the LAUNCHER category lines from existing intent-filters
          content = content.replace(
              '<category android:name="android.intent.category.LAUNCHER" />',
              '<!-- LAUNCHER moved to GeckoMainActivity -->'
          )

          # Add our activity before </application>
          gecko_activity = '''
                  <activity
                      android:name="com.geckovpn.client.ui.GeckoMainActivity"
                      android:label="GeckoVPN"
                      android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN" />
                          <category android:name="android.intent.category.LAUNCHER" />
                      </intent-filter>
                  </activity>
          '''

          content = content.replace('</application>', gecko_activity + '    </application>')

          with open("app/src/main/AndroidManifest.xml", "w") as f:
              f.write(content)

          print("Manifest patched successfully")
          PYEOF

          echo ""
          echo "=== Final AndroidManifest.xml ==="
          cat "${MANIFEST}"

      - name: Test ndk-build (dry run)
        run: |
          cd ss-full/src/frontends/android/app/src/main/jni
          ${ANDROID_NDK_HOME}/ndk-build \
            NDK_PROJECT_PATH=null \
            APP_BUILD_SCRIPT=$(pwd)/Android.mk \
            NDK_APPLICATION_MK=$(pwd)/Application.mk \
            APP_ABI=arm64-v8a \
            NDK_DEBUG=1 \
            APP_PLATFORM=android-21 \
            NDK_OUT=/tmp/ndk-out \
            NDK_LIBS_OUT=/tmp/ndk-libs \
            -n -B 2>&1 | tee /tmp/ndk-test.log || true
          echo ""
          echo "=== ERRORS ==="
          grep -i "undefined modules\|depends on\|No such file\|No rule to make\|Stop\." /tmp/ndk-test.log | head -20 || echo "No critical errors"

      - name: Build APK
        run: |
          cd ss-full/src/frontends/android
          echo "sdk.dir=${ANDROID_SDK_ROOT}" > local.properties
          sed -i "s|arguments '-j'|arguments 'APP_ALLOW_MISSING_DEPS=true', '-j'|" app/build.gradle
          set +e
          ./gradlew assembleDebug --no-daemon --stacktrace 2>&1 | tee "${GITHUB_WORKSPACE}/build.log"
          RESULT=${PIPESTATUS[0]}
          set -e
          if [ ${RESULT} -ne 0 ]; then
            echo ""
            echo "##############################################"
            echo "# BUILD FAILED"
            echo "##############################################"
            echo ""
            echo "=== Undefined module errors ==="
            grep -i "undefined modules\|depends on" "${GITHUB_WORKSPACE}/build.log" | head -10
            echo ""
            echo "=== Missing files ==="
            grep -i "No such file\|No rule to make" "${GITHUB_WORKSPACE}/build.log" | grep -v "Exception\|ProcessException" | head -10
            echo ""
            echo "=== Java compile errors ==="
            grep -E "error:" "${GITHUB_WORKSPACE}/build.log" | grep -v "Exception\|ProcessException\|CXX1429\|error when building\|IssueReporter\|TaskExecution\|EventFiring\|DefaultBuild" | head -30
            echo ""
            echo "=== Linker errors ==="
            grep "undefined reference\|undefined symbol\|cannot find -l\|recompile with -fPIC" "${GITHUB_WORKSPACE}/build.log" | head -20
            echo ""
            echo "=== Symbol not found ==="
            grep "cannot find symbol\|symbol:.*variable\|symbol:.*method\|symbol:.*class" "${GITHUB_WORKSPACE}/build.log" | head -20
            exit 1
          fi

      - name: Upload APK
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: geckovpn-debug-apk
          path: ss-full/src/frontends/android/app/build/outputs/apk/debug/*.apk
          if-no-files-found: error

      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          if-no-files-found: warn
